\documentclass[10pt,portrait]{article}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage{geometry}
\geometry{a4paper, portrait, margin=1cm, footskip=0.25in}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[pagestyles]{titlesec}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\title{Cheat Sheet ICPC}
\date{\vspace{-5ex}}
\newpagestyle{main}{\setfoot{}{}{\thepage}}
\pagestyle{main}
\linespread{1.0}
\assignpagestyle{\chapter}{main}

\begin{document}
\raggedright
\footnotesize
\maketitle
\tableofcontents
\pagebreak
\begin{multicols}{2}
% multicol parameters
% These lengths are set only within the two main columns

\begin{center}
     \Large{\underline{Cheat Sheet ICPC}} \\
     \small{Versi Dua Titik Nol}
\end{center}

\section{Dijkstra}

\begin{lstlisting}[language=C++]
int main () {
    int n,m;
    cin >> n >> m;
    vector<pii> adj[10005];
    for (int i=1;i<=m;i++) {
    int x,y,w;
    cin >> x >> y >> w;
    adj[x].pb(mp(w,y));
    }
    int s,e;
    cin >> s >> e;
    priority_queue<pii,vector<pii>,greater<pii> > d;
    int vis[10005];
    for (int i=1;i<=n;i++) vis[i]=INT_MAX;
    vis[s]=0;
    d.push(mp(0,s));
    while (!d.empty()) {
    pii cur=d.top();
    d.pop();
    for (int i=0;i<adj[cur.se].size();i++) {
      pii next=adj[cur.se][i];
      if (vis[cur.se]+next.fi<vis[next.se]) {
        vis[next.se]=vis[cur.se]+next.fi;
        d.push(mp(vis[next.se],next.se));
      }
    }
    }
    if (vis[e]==INT_MAX) cout << "NO" << endl; else cout << vis[e] << endl;
    return 0;
}

\end{lstlisting}

\section{MST}

\begin{lstlisting}[language=C++]
int main () {
    int n,m;
    cin >> n>> m;
    vector<pii> adj[10005];
    for (int i=1;i<=m;i++) {
      int u,v,w;
      cin >> u >> v >> w;
      adj[u].pb(mp(w,v));
      adj[v].pb(mp(w,u));
    }
    bool MST[10005];
    memset (MST,0,sizeof(MST));
    int vis[10005];
    for (int i=1;i<=n;i++) vis[i]=INT_MAX;
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    pq.push(mp(0,1));
    vis[1]=0;
    while (!pq.empty()) {
      pii cur=pq.top();
      pq.pop();
      MST[cur.se]=1;
      for (int i=0;i<adj[cur.se].size();i++) {
        pii next=adj[cur.se][i];
        if (!MST[next.se]&&vis[next.se]>next.fi) {
          vis[next.se]=next.fi;
          pq.push(next);
        }
      }
    }
    for (int i=1;i<=n;i++) cout << vis[i] << " ";
    return 0;
}

\end{lstlisting}
\section{Knapsack}

\begin{lstlisting}[language=C++]
int n,v[n+5],w[n+5],cap,dp[n+5];

int solve(int posi,int rem) {
  if (posi==0||rem==0) return 0;
  if (dp[posi][rem]!=-1) return dp[posi][rem];
  int ret=solve(posi-1,rem);
  if (rem>=w[posi]) ret=max(ret,solve(posi-1,rem-w[posi])+v[posi]);
  dp[posi][rem]=ret;
  return ret;
}

int main () {
  cin >> n;
  for (int i=1;i<=n;i++) cin >> v[i];
  for (int i=1;i<=n;i++) cin >> w[i];
  memset (dp,-1,sizeof(dp));
  cout << solve(n,cap) << endl;
  return 0;
}

\end{lstlisting}
\section{Coin Change}

\begin{lstlisting}[language=C++]
int n,m,c[55],dp[55][255];

int solve(int pos,int rem) {
    if (rem==0) return 1;
    if (pos<1||rem<0) return 0;
    if (dp[pos][rem]!=-1) return dp[pos][rem];
    return dp[pos][rem]=solve(pos,rem-c[pos])+solve(pos-1,rem);
}

int main () {
    cin >> n >> m;
    for (int i=1;i<=m;i++) cin >> c[i];
    memset (dp,-1,sizeof(dp));
    cout << solve(m,n);
    return 0;
}

\end{lstlisting}
\section{Negative Cycle Detection}

\begin{lstlisting}[language=C++]
int main () {
  int n,m;
  cin >> n >> m;
  vector<pair<pair<int,int>,int> > edge;
  for (int i=1;i<=m;i++) {
    int u,v,w;
    cin >> u >> v >> w;
    edge.pb(mp(mp(u,v),w));
  }
  int dist[35];
  for (int i=1;i<=n;i++) dist[i]=123456789;
  bool y=0;
  dist[1]=0;
  for (int i=1;i<n;i++) {
    for (int j=0;j<m;j++) {
      if (dist[edge[j].fi.se]>dist[edge[j].fi.fi]+edge[j].se) {
        dist[edge[j].fi.se]=dist[edge[j].fi.fi]+edge[j].se;
      }
    }
  }
  for (int i=0;i<m;i++) {
    if (dist[edge[i].fi.se]>dist[edge[i].fi.fi]+edge[i].se) {
      y=1;
    }
  }
  if (y) cout << "ada negative cycle" << endl;
  return 0;
}


\end{lstlisting}

\section{Toposort}

\begin{lstlisting}[language=C++]
stack<int> ans;
int vis[105];
bool cycle=0;
vector<int> adj[105];

void toposort(int x) {
  vis[x]=1;
  for (int j=0;j<adj[x].size();j++) {
    if (vis[adj[x][j]]==0) {
      vis[adj[x][j]]=1;
      toposort(adj[x][j]);
    } else if (vis[adj[x][j]]==1) cycle=1;
  }
  ans.push(x);
  vis[x]=2;
}

int main () {
    int n,m;
    cin >> n >> m;
    for (int i=1;i<=m;i++) {
      int x,y;
      cin >> x >> y;
      adj[x].pb(y);
    }
    memset (vis,0,sizeof(vis));
    for (int i=1;i<=n;i++) {
      if (!vis[i]) toposort(i);
    }

    if (cycle) cout << "Ada Cycle" << endl;
    else {
      while (!ans.empty()) {
        cout << ans.top() <<" ";
        ans.pop();
      }
    }
    return 0;
}

\end{lstlisting}
\section{nCr mod p}

\begin{lstlisting}[language=C++]
ll fastexp(ll x, ll y, ll p){
    ll res = 1;
    x = (x%p);
    while(y > 0){
        if(y&1){
            res = (res*x)%p;
        }
        y >>= 1;
        x = (x*x)%p;
    }
    return res;
}

ll mod_inverse(ll x, ll p){
    return fastexp(x,p-2,p)%p;
}

int nCrModPFermat(ll n,ll r,ll p){

    if(r == 0)
        return 1;

    ll fact[n+1];
    fact[0] = 1;
    for(int i=1;i<=n;i++){
        fact[i] = (fact[i-1]*i)%p;
    }
    return (fact[n]*mod_inverse(fact[n-r],p)*mod_inverse(fact[r],p))%p;
}

int main(){
    // p must be a prime greater than n
    cout << nCrModPFermat(12,3,13) << "\n";
    return 0;
}
\end{lstlisting}

\section{Sieve of Erastothenes}
\begin{lstlisting}[language=C++]
bitset<100000005> prima;

void sieve(int n) {
  prima.set();    //ubah semua jadi 1
  prima[0]=0;
  prima[1]=0;
  for (int i=2;i*i<=n;i++) {
      if (prima[i]) {
        for (int j=i*i;j<=n;j+=i) {
          prima[j]=0;
        }
      }
  }
}
\end{lstlisting}

\section{Modified Sieve}
\begin{lstlisting}[language=C++]
faktorisasi prima
int count[10005];
while (n!=1) {
	count[prima[n]]++;
	n/=prima[n];
}

number of prime divisors
for (int i=1;i<=n;i++) {
	if (prima[i]==0) {
		for (int j=i;j<=n;j+=i) {
			prima[j]++;
		}
	}
}

number of factors
for (int i=1;i<=n;i++) {
		for (int j=i;j<=n;j+=i) {
			prima[j]=i;
		}
}
\end{lstlisting}

\section{Fast Expo}
\begin{lstlisting}[language=C++]
LL poww(LL a,LL b) {
  if (b==0) return 1;
  if (b==1) return a;
  if (b%2==0) return ((poww(a,b/2)%MOD)*(poww(a,b/2)%MOD))%MOD;
  else return ((((poww(a,b/2)%MOD)*(poww(a,b/2)%MOD))%MOD)*a)%MOD;
}
\end{lstlisting}

\section{0-1 BFS}
\begin{lstlisting}[language=C++]
int n,m;
int x[4]={1,0,-1,0};
int y[4]={0,-1,0,1};
int vis[1005][1005];
char a[1005][1005];

bool inside(int a,int b) {
  if (a>=1&&a<=n&&b>=1&&b<=m) return 1;
  else return 0;
}

int main () {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin >> n >> m;
    for (int i=1;i<=n;i++) {
      string s;
      cin >> s;
      for (int j=1;j<=m;j++) {
        a[i][j]=s[j-1];
        vis[i][j]=INT_MAX;
      }
    }
    deque<pii> q;
    q.push_front(mp(1,1));
    vis[1][1]=0;
    while (!q.empty()) {
      pii cur=q.front();
      q.pop_front();
      for (int p=0;p<4;p++) {
        int nx=cur.fi+x[p],ny=cur.se+y[p];
        if (inside(nx,ny)&&vis[nx][ny]>vis[cur.fi][cur.se]) {
          if (a[nx][ny]==a[cur.fi][cur.se]) {  //cost=0
            vis[nx][ny]=vis[cur.fi][cur.se];
            q.push_front(mp(nx,ny));
          } else if (a[nx][ny]!=a[cur.fi][cur.se]){ //cost=1
            vis[nx][ny]=vis[cur.fi][cur.se]+1;
            q.push_back(mp(nx,ny));
          }
        }
      }
    }
    
    cout << vis[n][m] << endl;
    return 0;
}
\end{lstlisting}

\section{LCS}
\begin{lstlisting}[language=C++]
int n,m,dp[5005][5005];
string a,b;

int LCS(int p,int q) {
  if (p<=0||q<=0) return 0;
  if (dp[p][q]!=-1) return dp[p][q];
  if (a[p-1]==b[q-1]) return dp[p][q]=LCS(p-1,q-1)+1;
  else return dp[p][q]=max(LCS(p-1,q),LCS(p,q-1));
}

int main () {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin >> n >> m;
    cin >> a >> b;
    memset (dp,-1,sizeof(dp));
    int ans=LCS(n,m);
    string answer="";
    while (n>0&&m>0) {
      if (a[n-1]==b[m-1]) {
        answer+=a[n-1];
        n--;
        m--;
      } else if (dp[n-1][m]<dp[n][m-1]) m--;
      else n--;
    }
    reverse(answer.begin(),answer.end());
    if (answer.size()>0) cout << answer << endl; else cout << "NONE" << endl;
    return 0;
}
\end{lstlisting}

\section{LPS}
\begin{lstlisting}[language=C++]
LPS = LCS antara string dan reverse stringnya.
\end{lstlisting}

\section{Random}
\begin{lstlisting}[language=C++]
srand(time(NULL));  //HARUS ADA
// generate random numbers between [a,b)
rand() % (b - a) + a;
// generate random numbers between [0,b)
rand() % b;
// generate random permutations
random_permutation(anArray, anArray + 10);
random_permutation(aVector, aVector + 10);
\end{lstlisting}

\section{Prime number $<100$}
\begin{lstlisting}[language=C++]
2, 3, 5, 7, 11, 
13, 17, 19, 23, 29, 
31, 37,41, 43, 47, 
53, 59, 61, 67, 71, 
73, 79, 83, 89, 97
\end{lstlisting}

\section{Binomial Coefficient}
\begin{lstlisting}[language=C++]
#define MAXN 100 // largest n or m
long long bc[MAXN][MAXN];   //bc[n][r]=nCr
void binomial_coefficient(int n) {  
    for (int i=0; i<=n; i++) bc[i][0] = 1;
    for (int j=0; j<=n; j++) bc[j][j] = 1;
    for (int i=1; i<=n; i++)
    for (int j=1; j<i; j++)
        bc[i][j] = bc[i-1][j-1] + bc[i-1][j];
}
\end{lstlisting}

\section{Bignum Multiplication - JAVA}
\begin{lstlisting}[language=Java]
// fast algorithm to find multiplication of two big numbers.
import java.math.BigInteger;
import java.util.Random;
class Karatsuba {
	private final static BigInteger ZERO = new BigInteger("0");
	public static BigInteger karatsuba(BigInteger x, BigInteger y)
	{
		int N = Math.max(x.bitLength(), y.bitLength());
		if (N <= 2000) return x.multiply(y);
		N=(N/2)+(N %2);
		BigInteger b = x.shiftRight(N);
		BigInteger a = x.subtract(b.shiftLeft(N));
		BigInteger d = y.shiftRight(N);
		BigInteger c = y.subtract(d.shiftLeft(N));
		BigInteger ac = karatsuba(a, c);
		BigInteger bd = karatsuba(b, d);
		BigInteger abcd = karatsuba(a.add(b), c.add(d));
		return ac.add(abcd.subtract(ac).subtract(bd).shiftLeft(N)).add(bd.shiftLeft(2*N));
	}
	public static void main(String[] args)
	{
		long start, stop, elapsed;
		Random random = new Random();
		int N = Integer.parseInt(args[0]);
		BigInteger a = new BigInteger(N, random);
		BigInteger b = new BigInteger(N, random);
		start = System.currentTimeMillis();
		BigInteger c = karatsuba(a, b);
		stop = System.currentTimeMillis();
		System.out.println(stop - start);
		start = System.currentTimeMillis();
		BigInteger d = a.multiply(b);
		stop = System.currentTimeMillis();
		System.out.println(stop - start);
		System.out.println((c.equals(d)));
	}
}
\end{lstlisting}

\section{Euler totient function}
\begin{lstlisting}[language=C++]
// the positive integers less than or equal to n that are relatively prime to n.
int phi (int n)
{
	int result = n;
	for (int i=2; i*i<=n; ++i)
	if(n %i==0)
	{
		while(n %i==0)
		n /= i;
		result -= result / i;
	}
	if (n > 1)
	result -= result / n;
	return result;
}
\end{lstlisting}
Application:
$a^{\varphi(n)}\equiv 1 (mod n)$
kalau a dan m koprima

\section{Longest increasing common sequence (LICS)}
\begin{lstlisting}[language=C++]
int a[100];
int b[100];
int f[100];
int n=0, m=0;
int main() {
	cin >> n;
	for (int i=1;i<=n;i++) cin >> a[i];
	cin >> m;
	for (int i=1;i<=m;i++) cin >> b[i];
	for (int i=1;i<=n;i++) {
		int k=0;
		for (int j=1;j<=m;j++) {
			if (a[i]>b[j] && f[j]>k) k=f[j];
			else if (a[i]==b[j] && k+1>f[j]) f[j]=k+1;
		}
	}
	int ans=0;
	for (int i=1;i<=m;i++)
		if (f[i]>ans) ans=f[i];
	cout << ans << endl;
	return 0;
}
\end{lstlisting}

\section{LIS}
\begin{lstlisting}[language=C++]
int n=0;
int a[100], f[100], x[100];
int main() {
	cin >> n;
	for (int i=1;i<=n;i++) {
		cin >> a[i];
		x[i]=INT_MAX;
	}
	f[0]=0;
	int ans=0;
	for(int i=1;i<=n;i++) {
		int l=0, r=i;
		while (l+1<r) {
			int m=(l+r)/2;
			if (x[m]<a[i]) l=m; else r=m;
			// change to x[m]<=a[i] for non-decreasing case
		}
		f[i]=l+1;
		x[l+1]=a[i];
		if (f[i]>ans) ans=f[i];
	}
	cout << ans << endl;
	return 0;
}

\end{lstlisting}

\section{Max sum rectangle}
\begin{lstlisting}[language=C++]
int a[150][150]={0};
int c[200]={0};
int maxarray(int n) {
	int b=0, sum=-100000000;
	for (int i=1;i<=n;i++) {
		if (b>0) b+=c[i];
		else b=c[i];
		if (b>sum) sum=b;
	}
	return sum;
}

int maxmatrix(int n) {
	int sum=-100000000, max=0;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=n;j++)
			c[j]=0;
		for (int j=i;j<=n;j++) {
			for (int k=1;k<=n;k++)
				c[k]+=a[j][k];
			max=maxarray(n);
			if (max>sum) sum=max;
			}
	}
	return sum;
}

int main() {
	int n=0;
	cin >> n;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			cin >> a[i][j];
	cout << maxmatrix(n);
	return 0;
}
\end{lstlisting}

\section{Floyd Warshall}
\begin{lstlisting}[language=C++]
// map[i][j]=infinity at start
void floyd() {
    for (int k=1; k<=n; k++)
        for (int i=1; i<=n; i++)
            for (int j=1; j<=n; j++)
                if (i!=j && j!=k && i!=k)
                    if (map[i][k]+map[k][j]<map[i][j])
                        map[i][j]=map[i][k]+map[k][j];
}

\end{lstlisting}

\section{LCA+RMQ}
\begin{lstlisting}[language=C++]
struct LCA {
    vector<int> height, euler, first, segtree;
    vector<bool> visited;
    int n;

    LCA(vector<vector<int>> &adj, int root = 0) {
        n = adj.size();
        height.resize(n);
        first.resize(n);
        euler.reserve(n * 2);
        visited.assign(n, false);
        dfs(adj, root);
        int m = euler.size();
        segtree.resize(m * 4);
        build(1, 0, m - 1);
    }

    void dfs(vector<vector<int>> &adj, int node, int h = 0) {
        visited[node] = true;
        height[node] = h;
        first[node] = euler.size();
        euler.push_back(node);
        for (auto to : adj[node]) {
            if (!visited[to]) {
                dfs(adj, to, h + 1);
                euler.push_back(node);
            }
        }
    }

    void build(int node, int b, int e) {
        if (b == e) {
            segtree[node] = euler[b];
        } else {
            int mid = (b + e) / 2;
            build(node << 1, b, mid);
            build(node << 1 | 1, mid + 1, e);
            int l = segtree[node << 1], r = segtree[node << 1 | 1];
            segtree[node] = (height[l] < height[r]) ? l : r;
        }
    }

    int query(int node, int b, int e, int L, int R) {
        if (b > R || e < L)
            return -1;
        if (b >= L && e <= R)
            return segtree[node];
        int mid = (b + e) >> 1;

        int left = query(node << 1, b, mid, L, R);
        int right = query(node << 1 | 1, mid + 1, e, L, R);
        if (left == -1) return right;
        if (right == -1) return left;
        return height[left] < height[right] ? left : right;
    }

    int lca(int u, int v) {
        int left = first[u], right = first[v];
        if (left > right)
            swap(left, right);
        return query(1, 0, euler.size() - 1, left, right);
    }
};

\end{lstlisting}

\section{Segtree 1}
1=Update (add Z to elements indexed X to Y), 2=max and min per query
\begin{lstlisting}[language=C++]
const ll sz = 4e5+5;
ll seg[2][sz], lazy[sz], a[sz];
ll N, M, X, L, R, Y, Z;
 
void check(ll p, ll s, ll e) {
	if (lazy[p] != 0) {
		seg[0][p] += lazy[p];
		seg[1][p] += lazy[p];
		if (s != e) {
			lazy[2*p] += lazy[p];
			lazy[2*p+1] += lazy[p];
		}
		lazy[p] = 0;
	}
}
 
void build(ll p,ll s,ll e) {
	check(p,s,e); 
	if (s == e) {
		seg[0][p] = a[s];
		seg[1][p] = a[s];
		return;
	}
 
	build(2*p,s,(s+e)/2);
	build(2*p+1,(s+e)/2+1,e);
 
	seg[0][p] = min(seg[0][2*p], seg[0][2*p+1]);
	seg[1][p] = max(seg[1][2*p], seg[1][2*p+1]);
}
 
void update(ll p,ll s,ll e,ll a,ll b,ll v) {
	check(p,s,e);
	if(s >= a && e <= b) {
		seg[0][p] += v;
		seg[1][p] += v;
		if (s != e) {
			lazy[2*p] += v;
			lazy[2*p+1] += v;
		}
		return;
	}
	if(s > b || e < a) {
		return;
	}
	update(2*p,s,(s+e)/2,a,b,v);
	update(2*p+1,(s+e)/2+1,e,a,b,v);
	seg[0][p] = min(seg[0][2*p], seg[0][2*p+1]);
	seg[1][p] = max(seg[1][2*p], seg[1][2*p+1]);
}
 
ll getMin(ll p, ll s, ll e, ll a, ll b) {
	check(p,s,e);
 
	if (s >= a && e <= b) {
		return seg[0][p];
	}
	
	if (s > b || e < a) {
		return INT_MAX;
	}
 
	return min(getMin(2*p,s,(s+e)/2,a,b),getMin(2*p+1,(s+e)/2+1,e,a,b));
}
 
ll getMax(ll p, ll s, ll e, ll a, ll b) {
	check(p,s,e);
 
	if (s >= a && e <= b) {
		return seg[1][p];
	}
	
	if (s > b || e < a) {
		return INT_MIN;
	}
 
	return max(getMax(2*p,s,(s+e)/2,a,b),getMax(2*p+1,(s+e)/2+1,e,a,b));
}
 
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	memset(seg,0,sizeof(seg));
	cin >> N ;
	for (ll i = 0; i < N; i++) cin >> a[i];
	cin >> M;
	build(1,0,N-1);
	while (M--) {
		int p;
		cin >> p >> X >> Y;
		X--,Y--;
		if (p==1) {
			cin >> Z;
			update(1,0,N-1,X,Y,Z);
			continue;
		}
		cout << getMax(1,0,N-1,X,Y)-getMin(1,0,N-1,X,Y) << '\n';
	}
	return 0;
}
\end{lstlisting}

\section{Segtree 2}
\begin{lstlisting}[language=C++]
const int N = 100*1000;
int n;
int tree[2*N+3];

void build(){
    for(int i=n-1;i>0;i--){
        tree[i] = tree[2*i]+tree[2*i+1];
    }
}

void update(int p, int value){
    for(tree[p+=n] = value; p > 1; p/=2){
        tree[p/2] = tree[p]+tree[p^1];
    }
}

// query to add range [l,r)
int query(int l, int r){
    int sum = 0;
    for(l+=n, r+=n; l < r; l/=2, r/=2){
        cout << l << " " << r << "\n";
        if(l&1)sum += tree[l++];
        if(r&1)sum += tree[--r];
    }
    return sum;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n;
    for(int i=0;i<n;i++){
        cin >> tree[n+i];
    }
    build();
    for(int i=1;i<=2*n-1;i++){
        cout << i << " => " << tree[i] << "\n";
    }
    int l, r;
    cin >> l >> r;
    cout << query(l-1,r) << "\n";
    int pos, val;
    cin >> pos >> val;
    // update takes index and value as the parameter
    update(pos-1,val);
    cout << "Updated -> " << tree[n+pos] << "\n";
    for(int i=1;i<=2*n-1;i++){
        cout << i << " => " << tree[i] << "\n";
    }
    return 0;
}
\end{lstlisting}

\section{BIT}
\begin{lstlisting}[language=C++]
#include<bits/stdc++.h>
using namespace std;

// https://codeforces.com/contest/1185/problem/C2
// inspired by : https://codeforces.com/profile/Luqman

const int N = 2e5+5;

int n,m;
int t[N],sum[N], cnt[N], pos[N];

void add(int *bit, int i, int val){
    for(;i<=n;i+=i&-i){
        bit[i] += val;
    }
}

int get(int *bit, int i){
    int ret = 0;
    for(;i>0;i-=i&-i){
        ret += bit[i];
    }
    return ret;
}

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    vector<pair<int,int>> p(n+1);
    for(int i=1;i<=n;i++){
        cin >> t[i];
        p[i] = {t[i],i};
    }
    sort(p.begin()+1,p.begin()+1+n);
    for(int i=1;i<=n;i++){
        pos[p[i].second] = i;
    }
    for(int i=1;i<=n;i++){
        int req = m - t[i];
        int l = 0, r = n, ans;
        while(l<=r){
            int mid = (l+r)>>1;
            if(get(sum,mid) <= req){
                l = mid+1;
                ans = mid;
            }else{
                r = mid-1;
            }
        }
        cout << i - get(cnt,ans) - 1 << " ";
        add(sum,pos[i],t[i]);
        add(cnt,pos[i],1);
    }

    return 0;
}

\end{lstlisting}

\section{KMP}
\begin{lstlisting}[language=C++]
#define HHH 10003

int ne[HHH]; // next[], if par[i] not matched, jump to i = ne[i]
int kmp(string& par, string& ori) {
    ne[0] = -1;
    for (int p = ne[0], i = 1; i < par.length(); i++) {
        while (p >= 0 && par[p+1] != par[i])
            p = ne[p];
        if (par[p+1] == par[i])
            p++;
        ne[i] = p;
    }

    int match = 0;
    for (int p = -1, q = 0; q < ori.length(); q++) {
        while (p >= 0 && par[p+1] != ori[q])
            p = ne[p];
        if (par[p+1] == ori[q])
            p++;
        if (p + 1 == par.length()) { // match!
            p = ne[p];
            match++;
        }
    }

    return match; // return number of occurance
}

int main () {
    int n; 
    cin >> n;
    string par, ori;
    while (cin >> par >> ori)
        cout << kmp(par, ori) << endl;
    return 0;
}
\end{lstlisting}

\section{Kruskal MST}

\begin{lstlisting}[language=C++]
struct E{
    int u,v,w;
};

const int N = 100;
int T,n,m,a,b,c;
E temp;
vector<E> graph; // Store the inputted graph (u, v, w).
vector<E> selected_edges; // Store the edges which is selected for the MST from given graph.
int parent[N+2];

bool cstm(E a, E b){
    return a.w < b.w;
}

int findParent(int r){
    if(r == parent[r])return r;
    return parent[r] = findParent(parent[r]);
}

int Kruskal_MST(){

    for(int i=1;i<=n;i++)parent[i] = i;

    sort(graph.begin(),graph.end(),cstm);

    /*for(int i=0;i<graph.size();i++){
        cout << graph[i].w << "\n";
    }*/

    int edgeCounter = 0, totalCost = 0;

    int len = graph.size();

    for(int i=0; i<len;i++){

        int parent_of_u = findParent(graph[i].u);
        int parent_of_v = findParent(graph[i].v);

        if(parent_of_u != parent_of_v){
            parent[parent_of_u] = parent_of_v;
            totalCost += graph[i].w;
            selected_edges.pb(graph[i]);

            edgeCounter++;
            if(edgeCounter == n-1)
                break;
        }

    }
    return totalCost;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m;
    for(int i=1;i<=m;i++){
        cin >> a >> b >> c;
        temp.u = a, temp.v = b, temp.w = c;
        graph.pb(temp);
    }

    cout << Kruskal_MST() << "\n";

    return 0;
}

\end{lstlisting}

\section{NIM Game}
\begin{lstlisting}[language=C++]
Rules of the Game of Nim: There are n piles of coins. When it is a player’s turn he chooses one pile and takes at least one coin from it. If someone is unable to move he loses (so the one who removes the last coin is the winner).

Let n1, n2, ..., nk, be the sizes of the piles. It is a losing position for the player whose turn it is if and only if n1 xor n2 xor ... xor nk = 0.
\end{lstlisting}

\section{Convex Hull}
\begin{lstlisting}[language=C++]
pii p[100115],c[100115],P0;

double triangleArea(pii a,pii b, pii c) {
    return (a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y));
}

LL sqDist(pii a,pii b) {
    return ((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}

bool cmp(pii a,pii b) {
    double d=triangleArea(P0,a,b);
    if (d<0) return 0;
    return !(d==0&&sqDist(P0,a)>sqDist(P0,b));
} 

bool normal(pii a,pii b) {
    if (a.x==b.x) {
        return a.y<b.y;
    } else {
        return a.x<b.x;
    }
}

bool same(pii a,pii b) {
    return a.x==b.x && a.y==b.y;
}

void nosame(LL &np) {
    sort (p,p+np,normal);
    np=unique(p,p+np,same)-p;
}

void convexhull(LL &np, LL &nc) {
    LL pos=0,j;
    for (LL i=1;i<np;i++) {
        if (p[i].y<p[pos].y || (p[i].y==p[pos].y && p[i].x<p[pos].x)) pos=i;
    }
    swap(p[0],p[pos]);
    P0 = p[0];
    sort(&p[1],&p[np],cmp);
    for (LL i=0;i<3;i++) {
        c[i]=p[i];
    }
    for (LL i=j=3;i<np;i++) {
        while (triangleArea(c[j-2],c[j-1],p[i])<0) j--;
        c[j++]=p[i];
    }
    nc=j;
}

int main () {
    //clock_t start = clock();
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    double ans;
    LL np,nc;
    cin >> np;
    for (LL i=0;i<np;i++) cin >> p[i].x >> p[i].y;
    nosame(np);
    convexhull(np,nc);  // c berisi point yang ada dalam convex hull
    sort (c,c+nc,cmp);
    c[nc]=c[0];
    ans=0;
    //cout << endl;
    for (LL i=1;i<nc-1;i++) {
        ans+=abs(triangleArea(c[0], c[i], c[i+1]));
    }
    cout << fixed << setprecision(2) << ans/2 << endl;
    //cerr << fixed << setprecision(3) << (clock()-start)*1./CLOCKS_PER_SEC << endl;
    return 0;
}
\end{lstlisting}

\section{Weighted Activity Selection}
\begin{lstlisting}[language=C++]
// C++ program for weighted job scheduling using Dynamic
// Programming and Binary Search
#include <iostream>
#include <algorithm>
using namespace std;

// A job has start time, finish time and profit.
struct Job
{
    int start, finish, profit;
};

// A utility function that is used for sorting events
// according to finish time
bool myfunction(Job s1, Job s2)
{
    return (s1.finish < s2.finish);
}

// A Binary Search based function to find the latest job
// (before current job) that doesn't conflict with current
// job.  "index" is index of the current job.  This function
// returns -1 if all jobs before index conflict with it.
// The array jobs[] is sorted in increasing order of finish
// time.
int binarySearch(Job jobs[], int index)
{
    // Initialize 'lo' and 'hi' for Binary Search
    int lo = 0, hi = index - 1;

    // Perform binary Search iteratively
    while (lo <= hi)
    {
        int mid = (lo + hi) / 2;
        if (jobs[mid].finish < jobs[index].start)
        {
            if (jobs[mid + 1].finish < jobs[index].start)
                lo = mid + 1;
            else
                return mid;
        }
        else
            hi = mid - 1;
    }

    return -1;
}

// The main function that returns the maximum possible
// profit from given array of jobs
int findMaxProfit(Job arr[], int n)
{
    // Sort jobs according to finish time
    sort(arr, arr+n, myfunction);

    // Create an array to store solutions of subproblems.  table[i]
    // stores the profit for jobs till arr[i] (including arr[i])
    int *table = new int[n];
    table[0] = arr[0].profit;

    // Fill entries in table[] using recursive property
    for (int i=1; i<n; i++)
    {
        // Find profit including the current job
        int inclProf = arr[i].profit;
        int l = binarySearch(arr, i);
        if (l != -1)
            inclProf += table[l];

        // Store maximum of including and excluding
        table[i] = max(inclProf, table[i-1]);
    }

    // Store result and free dynamic memory allocated for table[]
    int result = table[n-1];
    delete[] table;

    return result;
}

// Driver program
int main()
{
    Job arr[100005];
    int n;
    cin >> n;
    for (int i=0;i<n;i++) cin >> arr[i].start >> arr[i].finish >> arr[i].profit;
    cout << findMaxProfit(arr, n);
    return 0;
}

\end{lstlisting}

\section{Matrix Expo}
\begin{lstlisting}[language=C++]
// C++ program to find value of f(n) where f(n)
// is defined as
//    F(n) = F(n-1) + F(n-2) + F(n-3), n >= 3
// Base Cases :
//    F(0) = 0, F(1) = 1, F(2) = 1
#include<bits/stdc++.h>
using namespace std;

// A utility function to multiply two matrices
// a[][] and b[][].  Multiplication result is
// stored back in b[][]
void multiply(int a[3][3], int b[3][3])
{
    // Creating an auxiliary matrix to store elements
    // of the multiplication matrix
    int mul[3][3];
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            mul[i][j] = 0;
            for (int k = 0; k < 3; k++)
                mul[i][j] += a[i][k]*b[k][j];
        }
    }

    // storing the muliplication resul in a[][]
    for (int i=0; i<3; i++)
        for (int j=0; j<3; j++)
            a[i][j] = mul[i][j];  // Updating our matrix
}

// Function to compute F raise to power n-2.
int power(int F[3][3], int n)
{
    int M[3][3] = {{1,1,1}, {1,0,0}, {0,1,0}};

    // Multiply it with initial values i.e with
    // F(0) = 0, F(1) = 1, F(2) = 1
    if (n==1)
        return F[0][0] + F[0][1];

    power(F, n/2);

    multiply(F, F);

    if (n%2 != 0)
        multiply(F, M);

    // Multiply it with initial values i.e with
    // F(0) = 0, F(1) = 1, F(2) = 1
    return F[0][0] + F[0][1] ;
}

// Return n'th term of a series defined using below
// recurrence relation.
// f(n) is defined as
//    f(n) = f(n-1) + f(n-2) + f(n-3), n>=3
// Base Cases :
//    f(0) = 0, f(1) = 1, f(2) = 1
int findNthTerm(int n)
{
    int F[3][3] = {{1,1,1}, {1,0,0}, {0,1,0}} ;

    return power(F, n-2);
}

// Driver code
int main()
{
   int n = 5;

   cout << "F(5) is " << findNthTerm(n);

   return 0;
}

\end{lstlisting}

\section{Mo's sum query}
\begin{lstlisting}[language=C++]
// Program to compute sum of ranges for different range
// queries
#include <bits/stdc++.h>
using namespace std;

// Variable to represent block size. This is made global
// so compare() of sort can use it.
int block;

// Structure to represent a query range
struct Query
{
    int L, R;
};

// Function used to sort all queries so that all queries
// of the same block are arranged together and within a block,
// queries are sorted in increasing order of R values.
bool compare(Query x, Query y)
{
    // Different blocks, sort by block.
    if (x.L/block != y.L/block)
        return x.L/block < y.L/block;

    // Same block, sort by R value
    return x.R < y.R;
}

// Prints sum of all query ranges. m is number of queries
// n is size of array a[].
void queryResults(int a[], int n, Query q[], int m)
{
    // Find block size
    block = (int)sqrt(n);
    cout << "block => " << block << "\n";
    // Sort all queries so that queries of same blocks
    // are arranged together.
    sort(q, q + m, compare);

    for(int i=0;i<m;i++){
        cout << q[i].L << " " << q[i].R << "\n";
    }
    cout << "\n";
    // Initialize current L, current R and current sum
    int currL = 0, currR = 0;
    int currSum = 0;

    // Traverse through all queries
    for (int i=0; i<m; i++)
    {
        // L and R values of current range
        int L = q[i].L, R = q[i].R;
        cout << L << "," << R << "\n";
        // Remove extra elements of previous range. For
        // example if previous range is [0, 3] and current
        // range is [2, 5], then a[0] and a[1] are subtracted
        while (currL < L)
        {
            currSum -= a[currL];
            currL++;
        }

        // Add Elements of current Range
        while (currL > L)
        {
            currSum += a[currL-1];
            currL--;
        }
        while (currR <= R)
        {
            currSum += a[currR];
            currR++;
        }

        // Remove elements of previous range.  For example
        // when previous range is [0, 10] and current range
        // is [3, 8], then a[9] and a[10] are subtracted
        while (currR > R+1)
        {
            currSum -= a[currR-1];
            currR--;
        }
        cout << currL << " " << currR << "\n";
        // Print sum of current range
        cout << "Sum of [" << L << ", " << R
             << "] is "  << currSum << endl;
    }
}

// Driver program
int main()
{
    int a[] = {1, 1, 2, 1, 3, 4, 5, 2, 8};
    int n = sizeof(a)/sizeof(a[0]);
    Query q[] = {{0, 4}, {1, 3}, {2, 4}};
    int m = sizeof(q)/sizeof(q[0]);
    queryResults(a, n, q, m);
    return 0;
}

\end{lstlisting}

\section{Edit Distance}
\begin{lstlisting}[language=C++]
string str1 = "sxyagf";
string str2 = "sabcf";
int n = (int)str1.size();
int m = (int)str2.size();

int minimum(int x, int y, int z){
    return min(min(x,y),z);
}

int recursive_edit_distance(int i, int j){
    // if the first string is empty then insert all character of second string
    if(i == 0){
        return j;
    }
    // vice versa with the second string
    if(j == 0){
        return i;
    }

    // if the last character is the same, then just skip
    if(str1[i-1] == str2[j-1]){
        return recursive_edit_distance(i-1,j-1);
    }
    // otherwise, consider all three options
    int insert = recursive_edit_distance(i,j-1);
    int remove = recursive_edit_distance(i-1,j);
    int replace = recursive_edit_distance(i-1,j-1);
    return 1 + minimum(insert,remove,replace);
}

int iterative_edit_distance(){
    int dp[n+3][m+3];
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            if(i == 0){
                dp[i][j] = j;
            }else if(j == 0){
                dp[i][j] = i;
            }else{
                if(str1[i-1] == str2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = 1 + minimum(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]);
                }
            }
        }
    }
    return dp[n][m];
}


int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);


    cout << recursive_edit_distance(n,m) << "\n";
    cout << iterative_edit_distance() << "\n";
    cout << lcs_solution() << "\n";

    return 0;
}
\end{lstlisting}

\section{DSU}
\begin{lstlisting}[language=C++]
int parent[200003];
int size[200003];


int find_set(int v){
    if(v == parent[v])return v;
    return parent[v] = find_set(parent[v]);
}

void make_set(int v){
    parent[v] = v;
    size[v] = 1;
}

void union_sets(int a, int b){
    a = find_set(a);
    b = find_set(b);
    if(a != b){
        if(size[a] < size[b])
            swap(a,b);
        parent[b] = a;
        size[a] += size[b];
    }
}
\end{lstlisting}

\section{Largest subsequence gcd}
\begin{lstlisting}[language=C++]
// https://www.geeksforgeeks.org/largest-subsequence-gcd-greater-1/

const int N = 15*1000*1000;
int prime[N+5], countdiv[N+5], n, a[300005];

int solve(){

    prime[1] = 1;
    for(int i=2;i*i<=N+3;i++){
        if(!prime[i]){
            for(int j=i;j<=N+3;j+=i)
                prime[j] = i;
        }
    }

    int fpb = a[1];
    forn(i,n)fpb = __gcd(fpb,a[i]);
    if(fpb>1)forn(i,n)a[i]/=fpb;
    int ans = 0;
    forn(i,n){
        int x = a[i];
        while(x > 1){
            int div = prime[x];
            ++countdiv[div];
            ans = max(ans,countdiv[div]);
            while(x%div == 0)
                x/=div;
        }
    }
    if(ans == 0)return -1;
    return n-ans;
}

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n;
    forn(i,n)cin>>a[i];
    cout << solve() << "\n";
    return 0;
}
\end{lstlisting}

\section{CRT}
\begin{lstlisting}[language=C++]
// make inverse_modulo using extended euclid algorithm
ll egcd(ll a, ll b, ll &x, ll &y){
    if(a == 0){
        x = 0, y = 1;
        return b;
    }
    ll x1,y1;
    ll d = egcd(b%a,a,x1,y1);
    x = y1-(b/a)*x1;
    y = x1;
    return d;
}

ll inv(ll a, ll b){
    ll x,y;
    egcd(a,b,x,y);
    return (x%b+b)%b;
}

ll findMinX(ll num[], ll rem[], int k){
    ll prod = 1;
    for(int i=0;i<k;i++){
        prod *= num[i];
    }
    ll res = 0;
    for(int i=0;i<k;i++){
        ll pp = prod/num[i];
        res += (rem[i]*inv(pp,num[i])*pp)%prod;
    }
    return res%prod;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    ll num[] = {3,4,5};
    ll rem[] = {2,3,1};
    // all of elements in num has to be coprime
    int k = sizeof(num)/sizeof(num[0]);
    cout << "x is " << findMinX(num, rem, k) << "\n";

    return 0;
}
\end{lstlisting}

\section{Extended Euclid}
\begin{lstlisting}[language=C++]
// to find (x,y) pair such that ax + by = gcd(a,b)
ll egcd(ll a, ll b, ll &x, ll &y){
    if(a == 0){
        x = 0; y = 1; return b;
    }
    ll x1, y1;
    ll d = egcd(b%a, a,x1,y1);
    x = y1-(b/a)*x1;
    y = x1;
    return d;
    // d = gcd(a,b)
}


int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    ll a,b,x,y;
    a = 4, b = 6;
    ll gcd = egcd(a,b,x,y);
    cout << x << " " << y << " " << gcd << "\n";
    // x = -1, y = 1, gcd = 2
    return 0;
}
\end{lstlisting}

\section{ModInv}
\begin{lstlisting}[language=C++]
// Task : Find c so that a = c (mod b)

// The multiplicative inverse of “a modulo m” exists
// if and only if a and m are relatively prime (i.e., if gcd(a, m) = 1).

int egcd(int a, int b, int &x, int &y){
    if(a == 0){
        x = 0, y = 1; return b;
    }
    int x1, y1, d = egcd(b%a, a, x1, y1);
    x = y1-(b/a)*x1;
    y = x1;
    return d;
}

// Function to find module invers a
// ax+by = 1 => ax = 1 (mod b), so our task is to find x
void modinverse1(int a, int b){
    int x,y;
    int g = egcd(a,b,x,y);
    if(g!=1){
        cout << "Inverse doesn't exist\n";
    }else{
        // b is added to handle negative x
        int res = (x%b+b)%b;
        cout << "Modular multiplicative inverse is " << res << "\n";
    }
}

// if b is prime, then we could use the exponation function
int fastexpo(int x, int y, int p){
    int res = 1;
    x = x%p;
    while(y > 0){
        if(y & 1){
            res = (res*x)%p;
        }
        y >>= 1;
        x = (x*x)%p;
    }
    return res%p;
}

void modinverse2(int a, int b){
    int g = __gcd(a,b);
    if(g != 1){
        cout << "Inverse doesn't exist\n";
    }else{
        cout << "Modular multiplicative inverse is ";
        cout << fastexpo(a,b-2,b) << "\n";
    }
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int a = 3, b = 17;
    modinverse1(a,b);
    modinverse2(a,b);
    return 0;
}

\end{lstlisting}

\section{Segtree 2D}
\begin{lstlisting}[language=C++]
const int N = 1024;
int n,tc;
int t[4*N+3][4*N+3];
int a[N+3][N+3];


void build_y(int vx, int sx, int ex, int vy, int sy, int ey){
    if(sy == ey){
        if(sx == ex){
            t[vx][vy] = a[sx][ey];
        }else{
            t[vx][vy] = t[2*vx][vy]+t[2*vx+1][vy];
        }
    }else{
        int my = (sy+ey)/2;
        build_y(vx,sx,ex,2*vy,sy,my);
        build_y(vx,sx,ex,2*vy+1,my+1,ey);
        t[vx][vy] = t[vx][2*vy]+t[vx][2*vy+1];
    }
}

void build_x(int vx, int sx, int ex){
    if(sx != ex){
        int mx = (sx+ex)/2;
        build_x(2*vx,sx,mx);
        build_x(2*vx+1,mx+1,ex);
    }
    build_y(vx,sx,ex,1,1,n);
}

void update_y(int vx, int sx, int ex, int vy, int sy, int ey, int x, int y, int val){
    if(sy == ey){
        if(sx == ex){
            t[vx][vy] = val;
        }else{
            t[vx][vy] = t[2*vx][vy]+t[2*vx+1][vy];
        }
    }else{
        int my = (sy+ey)/2;
        if(y<=my){
            update_y(vx,sx,ex,2*vy,sy,my,x,y,val);
        }else{
            update_y(vx,sx,ex,2*vy+1,my+1,ey,x,y,val);
        }
        t[vx][vy] = t[vx][2*vy]+t[vx][2*vy+1];
    }
}

void update_x(int vx, int sx, int ex, int x, int y, int val){
    if(sx!=ex){
        int mx = (sx+ex)/2;
        if(x <= mx){
            update_x(2*vx,sx,mx,x,y,val);
        }else{
            update_x(2*vx+1,mx+1,ex,x,y,val);
        }
    }
    update_y(vx,sx,ex,1,1,n,x,y,val);
}

int sum_y(int vx, int vy, int sy, int ey, int l, int r){
    //printf("**%d,%d,%d\n",vy,sy,ey);
    if(l > r || vy == 0 || l > ey || r < sy){
        return 0;
    }
    if(l <= sy && ey <= r){
        return t[vx][vy];
    }
    int my = (sy+ey)/2;
    int p1 = sum_y(vx,2*vy,sy,my,l,r);
    int p2 = sum_y(vx,2*vy+1,my+1,ey,l,r);
    return p1+p2;
}

int sum_x(int vx, int sx, int ex, int lx, int rx, int ly, int ry){
    //printf("%d,%d,%d\n",vx,sx,ex);
    if(lx > rx || vx == 0 || ex < lx || rx < sx){
        return 0;
    }
    if(lx <= sx && ex <= rx){
        return sum_y(vx,1,1,n,ly,ry);
    }
    int mx = (sx+ex)/2;
    int p1 = sum_x(2*vx,sx,mx,lx,rx,ly,ry);
    int p2 = sum_x(2*vx+1,mx+1,ex,lx,rx,ly,ry);
    return p1+p2;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin>>tc;
    MEM(t,0);
    while(tc--){
    cin >> n;
    forn(i,n){
        forn(j,n){
            a[i][j] = 0;
        }
    }
    while(true){
        string tt; cin >> tt;
        if(tt == "SET"){
            int x,y,val;
            cin>>x>>y>>val;
            update_x(1,1,n,x,y,val);
        }else if(tt == "SUM"){
            int lx,rx,ly,ry;
            cin >> lx >> ly >> rx >> ry;
            cout << sum_x(1,1,n,lx,rx,ly,ry) << "\n";
        }else if(tt == "END"){
            break;
        }
    }
    }
    return 0;
}
\end{lstlisting}

\section{String Hashing}
\begin{lstlisting}[language=C++]
long long compute_hash(string const& s) {
    const int p = 31;
    const int m = 1e9 + 9;
    long long hash_value = 0;
    long long p_pow = 1;
    for (char c : s) {
        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }
    return hash_value;
}

vector<vector<int>> group_identical_strings(vector<string> const& s) {
    int n = s.size();
    vector<pair<long long, int>> hashes(n);
    for (int i = 0; i < n; i++)
        hashes[i] = {compute_hash(s[i]), i};

    sort(hashes.begin(), hashes.end());

    vector<vector<int>> groups;
    for (int i = 0; i < n; i++) {
        if (i == 0 || hashes[i].first != hashes[i-1].first)
            groups.emplace_back();
        groups.back().push_back(hashes[i].second);
    }
    return groups;
}

int count_unique_substrings(string const& s) {
    int n = s.size();

    const int p = 31;
    const int m = 1e9 + 9;
    vector<long long> p_pow(n);
    p_pow[0] = 1;
    for (int i = 1; i < n; i++)
        p_pow[i] = (p_pow[i-1] * p) % m;

    vector<long long> h(n + 1, 0);
    for (int i = 0; i < n; i++)
        h[i+1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % m;

    int cnt = 0;
    for (int l = 1; l <= n; l++) {
        set<long long> hs;
        for (int i = 0; i <= n - l; i++) {
            long long cur_h = (h[i + l] + m - h[i]) % m;
            cur_h = (cur_h * p_pow[n-i-1]) % m;
            hs.insert(cur_h);
        }
        cnt += hs.size();
    }
    return cnt;
}
\end{lstlisting}

\section{Ternary Search}
\begin{lstlisting}[language=C++]
double f(double k){
    return - k * k;
}

double ternary_search(double l, double r){
    double eps = 1e-9; // set the error limit here
    while(r - l > eps){
        double m1 = l + (r - l)/3;
        double m2 = r - (r - l)/3;
        // evaluates the functions
        double f1 = f(m1);
        double f2 = f(m2);
        if(f1 < f2)
            l = m1;
        else
            r = m2;
    }
    return f(l);
}
\end{lstlisting}

\section{Trie}
\begin{lstlisting}[language=C++]
// A Trie node
struct Trie
{
	// true when node is a leaf node
	bool isLeaf;

	// each node stores a map to its child nodes
	unordered_map<char, Trie*> map;
};

// Function that returns a new Trie node
Trie* getNewTrieNode()
{
	Trie* node = new Trie;
	node->isLeaf = false;

	return node;
}

// Iterative function to insert a string in Trie.
void insert(Trie*& head, char* str)
{
	if (head == nullptr)
		head = getNewTrieNode();

	// start from root node
	Trie* curr = head;
	while (*str)
	{
		// create a new node if path doesn't exists
		if (curr->map.find(*str) == curr->map.end())
			curr->map[*str] = getNewTrieNode();

		// go to next node
		curr = curr->map[*str];

		// move to next character
		str++;
	}

	// mark current node as leaf
	curr->isLeaf = true;
}

// returns true if given node has any children
bool haveChildren(Trie const* curr)
{
	// don't use (curr->map).size() to check for children

	for (auto it : curr->map)
		if (it.second != nullptr)
			return true;

	return false;
}

// Recursive function to delete a string in Trie.
bool deletion(Trie*& curr, char* str)
{
	// return if Trie is empty
	if (curr == nullptr)
		return false;

	// if we have not reached the end of the string
	if (*str)
	{
		// recur for the node corresponding to next character in
		// the string and if it returns true, delete current node
		// (if it is non-leaf)
		if (curr != nullptr &&  curr->map.find(*str) != curr->map.end() &&
			deletion(curr->map[*str], str + 1) && curr->isLeaf == false)
		{
			if (!haveChildren(curr))
			{
				delete curr;;
				curr = nullptr;
				return true;
			}
			else {
				return false;
			}
		}
	}

	// if we have reached the end of the string
	if (*str == '\0' && curr->isLeaf)
	{
		// if current node is a leaf node and don't have any children
		if (!haveChildren(curr))
		{
			delete curr;; // delete current node
			curr = nullptr;
			return true; // delete non-leaf parent nodes
		}

		// if current node is a leaf node and have children
		else
		{
			// mark current node as non-leaf node (DON'T DELETE IT)
			curr->isLeaf = false;
			return false;	   // don't delete its parent nodes
		}
	}

	return false;
}

// Iterative function to search a string in Trie. It returns true
// if the string is found in the Trie, else it returns false
bool search(Trie* head, char* str)
{
	// return false if Trie is empty
	if (head == nullptr)
		return false;

	Trie* curr = head;
	while (*str)
	{
		// go to next node
		curr = curr->map[*str];

		// if string is invalid (reached end of path in Trie)
		if (curr == nullptr)
			return false;

		// move to next character
		str++;
	}

	// if current node is a leaf and we have reached the
	// end of the string, return true
	return curr->isLeaf;
}

// Memory efficient Trie Implementation in C++ using Map
int main()
{
	Trie* head = nullptr;
    char a[100] = "hello";

	insert(head, a);
	cout << search(head, a) << " ";   	// print 1

    char b[100] = "helloworld";
	insert(head, b);
	cout << search(head, b) << " ";  // print 1

    char c[100] = "hell";
	cout << search(head, c) << " ";   	// print 0 (Not present)

	insert(head, c);
	cout << search(head, c) << " ";		// print 1

    char d[100] = "h";
	insert(head, d);
	cout << search(head, d) << endl;  		// print 1 + newline

    char e[100] = "hello";
	deletion(head, e);
	cout << search(head, e) << " ";		// print 0

	return 0;
}
\end{lstlisting}

\section{Trie Minimum Xor}
\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;
int n, a[N], p[N];
struct Trie {
    struct Node {
        Node *child[2];
        int cnt;
        Node() {
            child[0] = child[1] = NULL;
            cnt = 0;
        }
    };

    Node *head;

    Trie() {
        head = new Node();
    }

    void insert(int val) {
        Node *cur = head;
        for (int i = 30; i >= 0; i--) {
            bool v = val & (1 << i);
            ++cur -> cnt;
            if (cur -> child[v] == NULL) {
                cur -> child[v] = new Node();
            }
            cur = cur -> child[v];
        }
        ++cur -> cnt;
    }

    void erase(int val) {
        Node *cur = head;
        for (int i = 30; i >= 0; i--) {
            bool v = val & (1 << i);
            --cur -> cnt;
            cur = cur -> child[v];
        }
        --cur -> cnt;
    }

    int getMinXOR(int val, int &id) {
        Node *cur = head;
        int res = 0, valz = val;
        for (int i = 30; i >= 0; i--) {
            bool v = val & (1 << i);
            if (cur -> child[v] != NULL && cur -> child[v] -> cnt != 0) {
                cur = cur -> child[v];
            } else {
                cur = cur -> child[v ^ 1];
                res += (1 << i);
                valz ^= (1 << i);
            }
        }
        id = lower_bound(p + 1, p + 1 + n, valz) - p;
        return res;
    }

};

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    Trie trie;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> p[i];
        trie.insert(p[i]);
    }
    sort(p + 1, p + 1 + n);
    for (int i = 1; i <= n; i++) {
        int id = 0;
        int res = trie.getMinXOR(a[i], id);
        cout << res << (i == n ? '\n' : ' ');
        trie.erase(p[id]);
    }

    return 0;
}

\end{lstlisting}

\section{Sqrt Decomposition}
\begin{lstlisting}[language=C++]
int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    // input data
    int n;
    vector<int> a (n);

    // preprocessing
    int len = (int) sqrt (n + .0) + 1; // size of the block and the number of blocks
    vector<int> b (len);
    for (int i=0; i<n; ++i)
        b[i / len] += a[i];

    // answering the queries
    for (;;) {
        int l, r;
        // read input data for the next query
        int sum = 0;
        for (int i=l; i<=r; )
            if (i % len == 0 && i + len - 1 <= r) {
                // if the whole block starting at i belongs to [l; r]
                sum += b[i / len];
                i += len;
            }
            else {
                sum += a[i];
                ++i;
            }
    }

    // A Better Approach
    int sum = 0;
    int c_l = l / len,   c_r = r / len;
    if (c_l == c_r)
        for (int i=l; i<=r; ++i)
            sum += a[i];
    else {
        for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)
            sum += a[i];
        for (int i=c_l+1; i<=c_r-1; ++i)
            sum += b[i];
        for (int i=c_r*len; i<=r; ++i)
            sum += a[i];
    }

    return 0;
}

\end{lstlisting}

\section{Hierholzer - Euclidean path}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
// Finding Euclidean Path
// from user https://codeforces.com/profile/yassin_
using namespace std;

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> bp(n - 1), cp(n - 1);
    set<int> s;
    for (int i = 0; i < n - 1; ++i) {
        cin >> bp[i];
    }
    for (int i = 0; i < n - 1; ++i) {
        cin >> cp[i];
    }
    for (int i = 0; i < n - 1; ++i) {
        if (bp[i] > cp[i]) {
            cout << -1 << "\n";
            return 0;
        }
        s.insert(bp[i]);
        s.insert(cp[i]);
    }
    map<int, int> id;
    vector<int> inv;
    int cur = 0;
    for (int x : s) {
        inv.push_back(x);
        id[x] = cur++;
    }
    vector<multiset<int>> g(cur);
    for (int i = 0; i < n - 1; ++i) {
        int u = id[bp[i]], v = id[cp[i]];
        g[u].insert(v);
        g[v].insert(u);
    }
    int cur_v = 0, cnt_odd = 0;
    for (int u = 0; u < cur; ++u) {
        if ((int)g[u].size() % 2 == 1) {
            cur_v = u;
            ++cnt_odd;
        }
    }
    if (cnt_odd != 0 && cnt_odd != 2) {
        cout << -1 << "\n";
        return 0;
    }
    vector<int> eul_path;
    stack<int> cur_path;
    cur_path.push(cur_v);
    while (!cur_path.empty()) {
        if (!g[cur_v].empty()) {
            cur_path.push(cur_v);
            int nxt_v = *g[cur_v].begin();
            g[cur_v].erase(g[cur_v].begin());
            g[nxt_v].erase(g[nxt_v].find(cur_v));
            cur_v = nxt_v;
        } else {
            eul_path.push_back(cur_v);
            cur_v = cur_path.top();
            cur_path.pop();
        }
    }
    if ((int)eul_path.size() < n) {
        cout << -1 << "\n";
        return 0;
    }
    for (int u : eul_path) {
        cout << inv[u] << " ";
    }
    cout << "\n";

    return 0;
}
\end{lstlisting}

\section{MST - Prim}
\begin{lstlisting}[language=C++]
ll n, m, u, v, w;
int s = 1; // let this be the source of the vertex

ll minSpanningTree(vector<pll> a[]){

    ll mst = 0;

    priority_queue<pll, vector<pll>, greater<pll> > pq;

    // create a vector key and initialize all of it to inf
    vector<ll> key(n+2,inf);

    // to store a parent which in turn store MST (optional)
    vector<ll> parent(n+2,-1);

    // To keep track of vertices included in MST
    vector<bool> inMST(n+2,false);

    pq.push(mp(0,s));
    key[s] = 0;
    while(!pq.empty()){
        int u = pq.top().ss;
        pq.pop();

        // include vertex u to the MST
        inMST[u] = true;

        for(int j=0; j<a[u].size();j++){
            int v = a[u][j].ff;
            int weight = a[u][j].ss;

            // if v is not yet in MST and weight of (u,v) is smaller
            // than the current key of v
            if(inMST[v] == false && key[v] > weight){
                // update the key[v]
                key[v] = weight;
                pq.push(mp(key[v],v));
                parent[v] = u;
            }
        }
    }

    // print edges of MST using parent array
    for (int i=1;i<=n;i++){
        cout << i << " => " << parent[i] << " => " << key[i] << "\n";
        mst += key[i];
    }
    return mst;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m;
    vector<pll> a[n+2];
    for(int i=1;i<=m;i++){
        cin >> u >> v >> w;
        a[u].pb(mp(v,w));
        a[v].pb(mp(u,w));
    }

    cout << minSpanningTree(a) << "\n";

    return 0;
}
\end{lstlisting}

\section{Bellman Ford}
\begin{lstlisting}[language=C++]
// n -> number of vertices
// m -> number of edges
int t,n,m,x,y,s,r,d;

bool BellmanFord(pair<int,pii> a[]){

    vector<int> dist(n+2,inf);
    dist[s] = 0;

    for(int i=1; i<=n-1;i++){
        for(int j=1; j<=m; j++){
            int u = a[j].ss.ff; // source
            int v = a[j].ss.ss; // destination
            int w = a[j].ff; // weight
            if(dist[u] != inf && dist[v] > dist[u]+w){
                dist[v] = dist[u]+w;
            }
        }
    }
    if(dist[d]==inf)dist[d] = 0;
    cout << dist[d] << "\n";

    // checking for negative cycle
    for(int j=1; j<=m; j++){
        int u = a[j].ss.ff;
        int v = a[j].ss.ss;
        int w = a[j].ff;
        if(dist[u] != inf && dist[v] > dist[u]+w){
            return true;
        }
    }
    return false;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> t;
    while(t--){
        cin >> n >> m;
        pair<int,pii> a[m+2];
        for(int i=1; i<=m;i++){
            cin >> x >> y >> r;
            a[i] = mp(r,mp(x,y));
        }
        cin >> s >> d;
        BellmanFord(a);
    }

    return 0;
}
\end{lstlisting}

\section{Second Shortest Path}
\begin{lstlisting}[language=C++]
const int MAXN = 5000;
int N,R,A,B,D, s = 1;
vector<pii> a[MAXN+2];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> R;
    for(int i=1;i<=R;i++){
        cin >> A >> B >> D;
        a[A].pb(mp(B,D));
        a[B].pb(mp(A,D));
    }
    priority_queue<pii, vector<pii>, greater<pii> > pq;
    vector<int> D(N+2, maximal);
    vector<int> D2(N+2, maximal);
    D[1] = 0;
    pq.push(mp(D[1],1));
    while(!pq.empty()){
        int w = pq.top().ff;
        int u = pq.top().ss;
        pq.pop();
        if(D2[u] < w)continue;
        for(int j=0; j<a[u].size(); j++){
            int node = a[u][j].ff;
            int weight = a[u][j].ss;
            int d = weight + w;
            if(d < D[node]){
                swap(d,D[node]);
                pq.push(mp(D[node],node));
            }
            if(D2[node] > d){
                D2[node] = d;
                pq.push(mp(D2[node],node));
            }
        }
    }
    cout << D2[N] << "\n";
    return 0;
}

\end{lstlisting}

\section{Coin Change - Minimum Needed}
\begin{lstlisting}[language=C++]
const int NMAX = 1000*1000;
int tc;
ll c[NMAX+3], v, n;
ll dp[NMAX+3];

// Optimal Substructure :
// dp[i] = the minimum coin needed to have a value i
// dp[0] = 0
// dp[i] = inf (if it is not possible to have a value i)
// dp[i] = min(dp[i], 1+dp[i - c[j-1]]) (if c[j-1] <= i)

ll minimum_coin(){
    dp[0] = 0; // if the value is 0 then include nothing
    for(int i=1;i<=v;i++){
        dp[i] = inf; // set dp[i] to infinite if it is not possible to have a value i
        for(int j=1;j<=n;j++){
            if(c[j-1] <= i){
                dp[i] = min(dp[i], 1+dp[i - c[j-1]]);
            }
        }
    }
    if(dp[v] == inf){
        dp[v] = -1;
    }
    return dp[v];
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> tc;
    while(tc--){
        cin >> v >> n;
        for(int i=0;i<n;i++){
            cin >> c[i];
        }
        cout << minimum_coin() << "\n";
    }

    return 0;
}

\end{lstlisting}

\section{DP n numbers to get x}
\begin{lstlisting}[language=C++]
// Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X
// https://www.geeksforgeeks.org/dice-throw-dp-30/
// https://practice.geeksforgeeks.org/problems/dice-throw/0

int tc, m,n,x;

// Optimal Substructure :
// dp[i][j] = number of ways to have a value j with i cubes
// dp[i][0] = 0 (if j < i)
// dp[i][j] = 1 (if i == j)
// dp[i][j] = 1 (if i == 1 and 1 <= j <= m) else 0
// dp[i][j] = sum(dp[i][j-k]) where 1 <= k <= j

ll dice_throw(){
    ll dp[n+3][x+3];
    for(int i=1;i<=n;i++){
        for(int j=0;j<=x;j++){
            if(j == 0){
                dp[i][j] = 0;
            }else if(i == 1){
                if(1 <= j  && j <= m){
                    dp[i][j] = 1;
                }else{
                    dp[i][j] = 0;
                }
            }else{
                if(j < i){
                    dp[i][j] = 0;
                }else if(i == j){
                    dp[i][j] = 1;
                }else{
                    dp[i][j] = 0;
                    for(int k=1;k<=min(m,j);k++){
                        dp[i][j] += dp[i-1][j-k];
                    }
                }
            }
        }
    }
    return dp[n][x];
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> tc;
    while(tc--){
        cin >> m >> n >> x;
        cout << dice_throw() << "\n";
    }

    return 0;
}

\end{lstlisting}

\section{Minimum Partition}
\begin{lstlisting}[language=C++]
// Given a set of integers
// the task is to divide it into two sets S1 and S2
// such that the absolute difference between their sums is minimum.

// Optimal Substructure :
// Use dp[i][j] where i is the number of elements and j is the value
// dp[i][j] = true (if there is a subset which has the sum j from 0 to i-1)
// dp[i][j] = false (otherwise)
// iterate from 0 to half of the sum and find the nearest to the half of the sum

const int NMAX = 100;
int tc, n;
int a[NMAX+3];

int minimum_partition(){
    int sum = accumulate(a,a+n,0);
    bool dp[n+3][sum+3];
    for(int i=0;i<=n;i++){
        for(int j=0;j<=sum;j++){
            if(j == 0){
                dp[i][j] = true;
            }else if(i == 0){
                dp[i][j] = false;
            }else{
                dp[i][j] = dp[i-1][j];
                if(a[i-1] <= j){
                    dp[i][j] = (dp[i-1][j] || dp[i-1][j-a[i-1]]);
                }
            }
        }
    }
    int ans = inf;
    for(int i=0;i<=sum/2;i++){
        if(dp[n][i]){
            ans = min(ans,sum - 2*i);
        }
    }
    return ans;
}
\end{lstlisting}

\section{Coin Game - Combinatorial}
\begin{lstlisting}[language=C++]
// Consider a row of n coins of values v1 . . . vn, where n is even.
// We play a game against an opponent by alternating turns.
// In each turn, a player selects either the first or last coin from the row,
// removes it from the row permanently, and receives the value of the coin.
// Determine the maximum possible amount of money we can definitely win if we move first.

const int NMAX = 1000;
ll a[NMAX+3], ans = 0;
int n;

// Optimal Substructure :
// dp[i][j] = a[i] (if i == j)
// dp[i][j] = max(a[i],a[j]) (if i+1 == j)
// dp[i][j] = max(a[i]+min(dp[i+2][j], dp[i+1][j-1]), a[j]+min(dp[i][j-2],dp[i+1][j-1]))

ll optimal_strategy(){

    if(n == 1){
        return a[n];
    }

    ll dp[n+3][n+3];

    for(int j=0;j<=n-1;j++){
        for(int i=1;i+j<=n;i++){
            if(j == 0){
                dp[i][i+j] = a[i];
            }else if(j == 1){
                dp[i][i+j] = max(a[i],a[i+j]);
            }else{
                int k = i+j;
                dp[i][k] = max(a[i]+min(dp[i+2][k],dp[i+1][k-1]),a[k]+min(dp[i][k-2],dp[i+1][k-1]));
            }
        }
    }

    return dp[1][n];
}

\end{lstlisting}

\section{Tarjan SCCC}
\begin{lstlisting}[language=c++]
// A C++ program to find strongly connected components in a given 
// directed graph using Tarjan's algorithm (single DFS) 
#include<iostream> 
#include <list> 
#include <stack> 
#define NIL -1 
using namespace std; 

// A class that represents an directed graph 
class Graph 
{ 
	int V; // No. of vertices 
	list<int> *adj; // A dynamic array of adjacency lists 

	// A Recursive DFS based function used by SCC() 
	void SCCUtil(int u, int disc[], int low[], 
				stack<int> *st, bool stackMember[]); 
public: 
	Graph(int V); // Constructor 
	void addEdge(int v, int w); // function to add an edge to graph 
	void SCC(); // prints strongly connected components 
}; 

Graph::Graph(int V) 
{ 
	this->V = V; 
	adj = new list<int>[V]; 
} 

void Graph::addEdge(int v, int w) 
{ 
	adj[v].push_back(w); 
} 

// A recursive function that finds and prints strongly connected 
// components using DFS traversal 
// u --> The vertex to be visited next 
// disc[] --> Stores discovery times of visited vertices 
// low[] -- >> earliest visited vertex (the vertex with minimum 
//			 discovery time) that can be reached from subtree 
//			 rooted with current vertex 
// *st -- >> To store all the connected ancestors (could be part 
//		 of SCC) 
// stackMember[] --> bit/index array for faster check whether 
//				 a node is in stack 
void Graph::SCCUtil(int u, int disc[], int low[], stack<int> *st, 
					bool stackMember[]) 
{ 
	// A static variable is used for simplicity, we can avoid use 
	// of static variable by passing a pointer. 
	static int time = 0; 

	// Initialize discovery time and low value 
	disc[u] = low[u] = ++time; 
	st->push(u); 
	stackMember[u] = true; 

	// Go through all vertices adjacent to this 
	list<int>::iterator i; 
	for (i = adj[u].begin(); i != adj[u].end(); ++i) 
	{ 
		int v = *i; // v is current adjacent of 'u' 

		// If v is not visited yet, then recur for it 
		if (disc[v] == -1) 
		{ 
			SCCUtil(v, disc, low, st, stackMember); 

			// Check if the subtree rooted with 'v' has a 
			// connection to one of the ancestors of 'u' 
			// Case 1 (per above discussion on Disc and Low value) 
			low[u] = min(low[u], low[v]); 
		} 

		// Update low value of 'u' only of 'v' is still in stack 
		// (i.e. it's a back edge, not cross edge). 
		// Case 2 (per above discussion on Disc and Low value) 
		else if (stackMember[v] == true) 
			low[u] = min(low[u], disc[v]); 
	} 

	// head node found, pop the stack and print an SCC 
	int w = 0; // To store stack extracted vertices 
	if (low[u] == disc[u]) 
	{ 
		while (st->top() != u) 
		{ 
			w = (int) st->top(); 
			cout << w << " "; 
			stackMember[w] = false; 
			st->pop(); 
		} 
		w = (int) st->top(); 
		cout << w << "\n"; 
		stackMember[w] = false; 
		st->pop(); 
	} 
} 

// The function to do DFS traversal. It uses SCCUtil() 
void Graph::SCC() 
{ 
	int *disc = new int[V]; 
	int *low = new int[V]; 
	bool *stackMember = new bool[V]; 
	stack<int> *st = new stack<int>(); 

	// Initialize disc and low, and stackMember arrays 
	for (int i = 0; i < V; i++) 
	{ 
		disc[i] = NIL; 
		low[i] = NIL; 
		stackMember[i] = false; 
	} 

	// Call the recursive helper function to find strongly 
	// connected components in DFS tree with vertex 'i' 
	for (int i = 0; i < V; i++) 
		if (disc[i] == NIL) 
			SCCUtil(i, disc, low, st, stackMember); 
} 

// Driver program to test above function 
int main() 
{ 
	cout << "\nSCCs in first graph \n"; 
	Graph g1(5); 
	g1.addEdge(1, 0); 
	g1.addEdge(0, 2); 
	g1.addEdge(2, 1); 
	g1.addEdge(0, 3); 
	g1.addEdge(3, 4); 
	g1.SCC(); 

	cout << "\nSCCs in second graph \n"; 
	Graph g2(4); 
	g2.addEdge(0, 1); 
	g2.addEdge(1, 2); 
	g2.addEdge(2, 3); 
	g2.SCC(); 

	cout << "\nSCCs in third graph \n"; 
	Graph g3(7); 
	g3.addEdge(0, 1); 
	g3.addEdge(1, 2); 
	g3.addEdge(2, 0); 
	g3.addEdge(1, 3); 
	g3.addEdge(1, 4); 
	g3.addEdge(1, 6); 
	g3.addEdge(3, 5); 
	g3.addEdge(4, 5); 
	g3.SCC(); 

	cout << "\nSCCs in fourth graph \n"; 
	Graph g4(11); 
	g4.addEdge(0,1);g4.addEdge(0,3); 
	g4.addEdge(1,2);g4.addEdge(1,4); 
	g4.addEdge(2,0);g4.addEdge(2,6); 
	g4.addEdge(3,2); 
	g4.addEdge(4,5);g4.addEdge(4,6); 
	g4.addEdge(5,6);g4.addEdge(5,7);g4.addEdge(5,8);g4.addEdge(5,9); 
	g4.addEdge(6,4); 
	g4.addEdge(7,9); 
	g4.addEdge(8,9); 
	g4.addEdge(9,8); 
	g4.SCC(); 

	cout << "\nSCCs in fifth graph \n"; 
	Graph g5(5); 
	g5.addEdge(0,1); 
	g5.addEdge(1,2); 
	g5.addEdge(2,3); 
	g5.addEdge(2,4); 
	g5.addEdge(3,0); 
	g5.addEdge(4,2); 
	g5.SCC(); 

	return 0; 
} 

\end{lstlisting}

\section{Zeckendorf - Fibonacci Fractal}
\begin{lstlisting}[language=C++]
int main () {
    //clock_t start = clock();
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    LL x;
    LL f[55];
    f[0]=0;
    f[1]=1;
    f[2]=1;
    for (int i=3;i<=50;i++) {
        f[i] = f[i-1] + f[i-2];
    }
    while (cin >> x) {
        if (x==0) return 0;
        else if (x==1) cout << "We're Dead" << endl;
        else {
            int p=0;
            for (int i=1;i<=50;i++) {
                if (x>=f[i]) p=i;
            }
            if (f[p] == x) {
                cout << "I'm Dead" << endl;
            } else {
                x-=f[p];
                //cout << x << endl;
                while (1) {
                    LL g=0;
                    for (int i=0;i<=50;i++) {
                        if (x>=f[i]) g=i;
                    }
                    if (x == f[g]) break; else x-=f[g];
                }
                cout << x << endl;
            }
        }
    }
    //cerr << fixed << setprecision(3) << (clock()-start)*1./CLOCKS_PER_SEC << endl;
    return 0;
}
\end{lstlisting}
\begin{lstlisting}[language=c++]
// C++ program for implementation of Ford Fulkerson algorithm 
#include <iostream> 
#include <limits.h> 
#include <string.h> 
#include <queue> 
using namespace std; 

// Number of vertices in given graph 
#define V 6 

/* Returns true if there is a path from source 's' to sink 't' in 
residual graph. Also fills parent[] to store the path */
bool bfs(int rGraph[V][V], int s, int t, int parent[]) 
{ 
	// Create a visited array and mark all vertices as not visited 
	bool visited[V]; 
	memset(visited, 0, sizeof(visited)); 

	// Create a queue, enqueue source vertex and mark source vertex 
	// as visited 
	queue <int> q; 
	q.push(s); 
	visited[s] = true; 
	parent[s] = -1; 

	// Standard BFS Loop 
	while (!q.empty()) 
	{ 
		int u = q.front(); 
		q.pop(); 

		for (int v=0; v<V; v++) 
		{ 
			if (visited[v]==false && rGraph[u][v] > 0) 
			{ 
				q.push(v); 
				parent[v] = u; 
				visited[v] = true; 
			} 
		} 
	} 

	// If we reached sink in BFS starting from source, then return 
	// true, else false 
	return (visited[t] == true); 
} 

// Returns the maximum flow from s to t in the given graph 
int fordFulkerson(int graph[V][V], int s, int t) 
{ 
	int u, v; 

	// Create a residual graph and fill the residual graph with 
	// given capacities in the original graph as residual capacities 
	// in residual graph 
	int rGraph[V][V]; // Residual graph where rGraph[i][j] indicates 
					// residual capacity of edge from i to j (if there 
					// is an edge. If rGraph[i][j] is 0, then there is not) 
	for (u = 0; u < V; u++) 
		for (v = 0; v < V; v++) 
			rGraph[u][v] = graph[u][v]; 

	int parent[V]; // This array is filled by BFS and to store path 

	int max_flow = 0; // There is no flow initially 

	// Augment the flow while tere is path from source to sink 
	while (bfs(rGraph, s, t, parent)) 
	{ 
		// Find minimum residual capacity of the edges along the 
		// path filled by BFS. Or we can say find the maximum flow 
		// through the path found. 
		int path_flow = INT_MAX; 
		for (v=t; v!=s; v=parent[v]) 
		{ 
			u = parent[v]; 
			path_flow = min(path_flow, rGraph[u][v]); 
		} 

		// update residual capacities of the edges and reverse edges 
		// along the path 
		for (v=t; v != s; v=parent[v]) 
		{ 
			u = parent[v]; 
			rGraph[u][v] -= path_flow; 
			rGraph[v][u] += path_flow; 
		} 

		// Add path flow to overall flow 
		max_flow += path_flow; 
	} 

	// Return the overall flow 
	return max_flow; 
} 

// Driver program to test above functions 
int main() 
{ 
	// Let us create a graph shown in the above example 
	int graph[V][V] = { {0, 16, 13, 0, 0, 0}, 
						{0, 0, 10, 12, 0, 0}, 
						{0, 4, 0, 0, 14, 0}, 
						{0, 0, 9, 0, 0, 20}, 
						{0, 0, 0, 7, 0, 4}, 
						{0, 0, 0, 0, 0, 0} 
					}; 

	cout << "The maximum possible flow is " << fordFulkerson(graph, 0, 5); 

	return 0; 
} 

\end{lstlisting}
% You can even have references
\rule{0.3\linewidth}{0.25pt}
\scriptsize
\bibliographystyle{abstract}
\bibliography{refFile}
\end{multicols}
\end{document}